\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{clrscode3e}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows}
\usepackage{setspace}
\usepackage{mathpazo}
%\usepackage{tikz-berge}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}

 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\renewcommand{\'}{^{'}}
\renewcommand{\gets}{:=}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{definition}[2][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{question}[2][Question]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\begin{document}
\title{Auction algorithm}
\author{Zachary Campbell}

\maketitle
\doublespacing
We now look at a cool application of weighted bipartite matching. Consider an auction scenario, where 
there is a set $B$ of bidders, a set $G$ of goods, and costs $c_{ij}$ that quantifies the amount 
that bidder $i\in B$ is willing to pay for good $j\in G$. This can easily be modeled with a 
weighted bipartite graph. Our goal is to maximize the total amount earned in the auction -- i.e. to 
maximize $\sum_{(i,j)} c_{ij}$, under the constraint that no bidder gets more than one good, and no 
good is purchased by more than one bidder. \\
The algorithm presented here is an alternative to the alternating path algorithms we have discussed. 
\singlespace
\begin{codebox}
	\Procname{$\proc{Alg 1}$}
	\li For each $j\in G$, set $p_j \gets 0$ and $owner_j \gets null$.
	\li Queue $Q \gets B$.
	\li Set $\delta = 1/(|G| + 1)$.
	\li \While $Q\neq \emptyset$
		\Do
	\li		$i = Q.deque()$
	\li		Find $j\in G$ that maximizes $c_{ij} - p_{j}$
	\li		\If $c_{ij} - p_{j} \geq 0$
				\Then
	\li				$Q.enqueue(owner_j)$
	\li				$owner_j = i$
	\li				$p_j = p_j + \delta$
				\End
		\End
	\li \Return $(owner_j,j)$ for all $j$.
\end{codebox}
\doublespacing
\begin{definition}{}
	We say that a bidder $i$ is $\delta$-happy if one of the following is true:
	\begin{enumerate}
		\item $i$ is the owner of some good $j$, and for all other goods $j\'$, we have that 
			$\delta + c_{ij} - p_j \geq c_{ij\'} - p_{j\'}$, i.e. our $i$ has the good $j$ 
			that maximizes the value of their contribution.
		\item for no good $j$ does it hold that $owner_j = i$ and for all goods $j$ 
			$w_{ij} \leq p_j$.
	\end{enumerate}
\end{definition}

What we will show is that the algorithm reaches an equilibrium in which all bidders are ``happy,'' as 
defined above. The loop invariant is that all bidders not in $Q$ are $\delta$-happy. This is 
clearly true at the beginning, as all bidders start in our queue. When a bidder $i$ is dequeued, 
line $6$ in our loop chooses good $j$ that maximizes $w_{ij} - p_j$, which means it chooses a good 
that makes $i$ $\delta$-happy, if such a good exists. We need to confirm that this step does not 
hurt the invariant for any other bidder $i\'$. Well, an increase in $p_j$ by $\delta$ for any $j$ 
not own by $i\'$ does not violate the inequality $\delta + w_{i\' j\'} - p_{j\'} \geq w_{i\' j} - p_j$. 
On the other hand, if $i\'$ did own $j$, this means that $i\'$ has been thrown back into $Q$, so $i\'$ 
no longer owns anything.

\begin{lemma}{}
	If all bidders are $\delta$-happy then for every matching $M\'$ we have that 
	\[
		n\delta + \sum_{i = owner_j} w_{ij} \geq \sum_{(i,j)\in M\'} w_{ij},
	\]
	where $n$ is the number of bidders. 
\end{lemma}

First, note that hthis lemma implies the correctness of our algorithm. Since $n\delta < 1$ and all of 
our weights are integral, this proving this inequality will show that the matching we output is 
a maximum matching.

\begin{proof}
	Fix a bidder $i$, and let good $j$ be such that $i = owner_j$. Let $j\'$ be the good assigned 
	to $i$ in $M\'$. (Note: these could be \emph{null}, in which case we adopt the convention of 
	assigning their weights and prices to be zero.) Since $i$ is $\delta$-happy, we have that 
	$\delta + w_{ij} - p_j \geq w_{ij} - p_j$. Now let's summ over all $i$ to get 
	\[
		\sum_{i=owner_j} (\delta + w_{ij} - p_j) \geq \sum_{(i,j\')\in M\'} (w_{ij\'} - p_j).
	\]
	We know that our algorithm gives us a matching, as does $M\'$, which means that each good $j$ 
	can only appear at most once on each side of this inequality. So if we substract $\sum_j p_j$ 
	from each side, and rearrange a bit, we get 
	\[
		\sum_{i=owner_j} \delta + \sum_{i=owner_j} w_{ij} \geq \sum_{(i,j\')\in M\'} (w_{ij\'}). 
	\]
	But $\sum_{i=owner_j} \delta \leq n\delta$, which gives us what we want.
\end{proof}

\end{document}
